You’ve made it to the end of a significant section on asynchronous programming, promises, and apis. Some deep computer science concepts showed up so let’s take a moment to review them:

- Synchronous programming refers to programs that run sequentially, from top to bottom, that may or may not encounter blocking operations that affect the run time.

- Asynchronous programming refers to programs that run on a looped operation and divert blocking operations to handlers in order maintain the run time.

- User interfaces and browsers implements systems based on asynchronous programming in order to handle the unpredictability of user events such as clicks, mouse moves, and more.

- ES6 promises allow programs to handle asynchronous processes by representing values that will return at some point in the future.

- Promises can exist in one of the three following states: pending, fulfilled, and rejected.

- HTTP or HyperText Transfer Protocol defines the foundation for data communication over the world wide web.

    HTTP Request methods include:

    - GET for retrieving data from a server

    - POST for sending data to a server

    - HEAD, DELETE, PATCH, and more…

The **Fetch** method begins to provide access in ES6 to HTTP request methods and grab data from APIs by returning a **PROMISE** that stands in for **resulting data**.

Overall, all ES6 programmers must understand how to implement promises in ES6. But when you reduce the **Promise** down to the simple idea of **a stand in value for pending, fulfilled, and rejected state**, the concept becomes clear.

Plus, with promises you have the full power of the Internet’s vast array of APIs at your disposal. And when you can combine more than one API, you’ll have a truly awesome project on your hands.

That’s a closing promise!